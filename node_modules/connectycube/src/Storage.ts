import ProxyService from './Proxy';
import Utils from './Utils';
import config from './config';
import { EmptyResponse, Proxy, Storage } from './types';
import { ProxyMethod, ProxyType } from './types/proxy';

export default class StorageService {
  public proxy: ProxyService;
  readonly route = config.urls.blobs;

  constructor(proxy: ProxyService) {
    this.proxy = proxy;
  }

  public async list(params: Storage.ListParams = {}): Promise<Storage.ListResponse> {
    const ajaxParams = {
      type: ProxyMethod.GET,
      url: Utils.getUrl(this.route),
      data: params,
    };

    return this.proxy.ajax(ajaxParams);
  }

  public async create(params?: Storage.CreateParams): Promise<Storage.BlobResponse> {
    const ajaxParams = {
      type: ProxyMethod.POST,
      url: Utils.getUrl(this.route),
      data: { blob: params },
    };

    return this.proxy.ajax(ajaxParams);
  }

  public async delete(id: number | string): Promise<EmptyResponse> {
    const ajaxParams = {
      type: ProxyMethod.DELETE,
      url: Utils.getUrl(this.route, id),
      dataType: ProxyType.TEXT,
    };

    return this.proxy.ajax(ajaxParams);
  }

  public async createAndUpload(params: Storage.CreateAndUploadParams): Promise<Storage.Blob> {
    const { name, file, size, abort_id, type: content_type, public: isPublic = true } = params;
    const createParams = { name, content_type, public: isPublic };

    let blob: Storage.Blob;

    return this.create(createParams)
      .then(({ blob: blobObject }) => {
        blob = blobObject;
        const uri = this.parseUri(blob.blob_object_access?.params);
        const uploadUrl = `${uri.protocol}://${uri.authority}${uri.path}`;
        const uploadParams: Proxy.Params = { url: uploadUrl, data: {} };

        if (abort_id) {
          uploadParams.abort_id = abort_id;
        }

        Object.keys(uri.queryKey).forEach((key) => {
          uploadParams.data[key] = decodeURIComponent(uri.queryKey[key]);
        });

        uploadParams.data.file = file;

        return this.upload(uploadParams).then(() => blob);
      })
      .then((blob) => this.markUploaded({ id: blob.id, size }).then(() => blob))
      .then((blob) => ({ ...blob, size }));
  }

  public async upload(params: Proxy.Params): Promise<any> {
    const ajaxParams = {
      ...params,
      type: ProxyMethod.POST,
      dataType: ProxyType.TEXT,
      contentType: false,
    };

    return this.proxy.ajax(ajaxParams);
  }

  public async markUploaded(params: Storage.MarkUploadedParams): Promise<EmptyResponse> {
    const ajaxParams = {
      type: ProxyMethod.PUT,
      url: Utils.getUrl(this.route, params.id, 'complete'),
      data: {
        size: params.size,
      },
      dataType: ProxyType.TEXT,
    };

    return this.proxy.ajax(ajaxParams);
  }

  public async getInfo(id: number | string): Promise<Storage.BlobResponse> {
    const ajaxParams = {
      url: Utils.getUrl(this.route, id),
    };

    return this.proxy.ajax(ajaxParams);
  }

  public async getFile(uid: string): Promise<Storage.BlobResponse> {
    const ajaxParams = {
      url: Utils.getUrl(this.route, uid),
    };

    return this.proxy.ajax(ajaxParams);
  }

  public async getFileObject(uid: string, params: Storage.GetFileObjectParams): Promise<Storage.BlobResponse> {
    const ajaxParams = {
      type: ProxyMethod.GET,
      url: Utils.getUrl(this.route, uid, 'object'),
      data: params,
    };

    return this.proxy.ajax(ajaxParams);
  }

  public async update(params: Storage.UpdateParams): Promise<Storage.BlobResponse> {
    const data = { blob: {} as any };

    if (typeof params.name !== 'undefined') {
      data.blob.name = params.name;
    }

    const ajaxParams = {
      url: Utils.getUrl(this.route, params.id),
      data: data,
    };

    return this.proxy.ajax(ajaxParams);
  }

  public privateUrl(fileUID: string = ''): string {
    return `https://${config.endpoints.api}/blobs/${fileUID}?token=${this.proxy.getSession()?.token}`;
  }

  public publicUrl(fileUID: string = ''): string {
    return `https://${config.endpoints.api}/blobs/${fileUID}`;
  }

  // parseUri 1.2.2
  // (c) Steven Levithan <stevenlevithan.com>
  // MIT License
  // http://blog.stevenlevithan.com/archives/parseuri
  private parseUri(str: string = ''): any {
    const options = {
      strictMode: false,
      key: [
        'source',
        'protocol',
        'authority',
        'userInfo',
        'user',
        'password',
        'host',
        'port',
        'relative',
        'path',
        'directory',
        'file',
        'query',
        'anchor',
      ],
      q: {
        name: 'queryKey',
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g,
      },
      parser: {
        strict:
          /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose:
          /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
      },
    };
    const m = options.parser[options.strictMode ? 'strict' : 'loose'].exec(str) ?? {};

    const uri = {};
    let i = 14;

    while (i--) {
      uri[options.key[i]] = m[i] || '';
    }

    uri[options.q.name] = {};
    uri[options.key[12]].replace(options.q.parser, ($0, $1, $2) => {
      if ($1) {
        uri[options.q.name][$1] = $2;
      }
    });

    return uri;
  }
}
