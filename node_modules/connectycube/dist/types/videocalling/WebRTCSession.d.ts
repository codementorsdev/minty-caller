import WebRTCPeerConnection from './WebRTCPeerConnection';
import WebRTCSignalingProvider from './WebRTCSignalingProvider';
import { SessionState, PeerConnectionState, CallType, SessionConnectionState } from '../types/calls';
import { Calls, Media } from '../types';
export default class WebRTCSession {
    ID: string | null;
    state: SessionState;
    callType: CallType;
    initiatorID: number;
    currentUserID: number;
    opponentsIDs: number[];
    maxBandwidth: number;
    peerConnections: {
        [userID: number]: WebRTCPeerConnection;
    };
    localStream?: MediaStream;
    mediaParams: MediaStreamConstraints;
    signalingProvider: WebRTCSignalingProvider;
    answerTimer: NodeJS.Timeout | null;
    waitingOfferOrAnswerTimer: NodeJS.Timeout | null;
    startCallDate: Date;
    acceptCallDate: Date;
    onUserNotAnswerListener: Calls.OnUserNotAnswerListener;
    onRemoteStreamListener: Calls.OnRemoteStreamListener;
    onSessionCloseListener: Calls.OnSessionCloseListener;
    onCallStatsReportListener: Calls.OnCallStatsReportListener;
    onSessionConnectionStateChangedListener: Calls.OnSessionConnectionStateChangedListener;
    constructor(params: Calls.WebRTCSessionParams);
    getDisplayMedia(params: Media.DisplayParams): Promise<MediaStream>;
    getUserMedia(params: Media.UserParams): Promise<MediaStream>;
    private upsertStream;
    private replaceTracks;
    setMaxBandwidth(maxBandwidth: number): Promise<any>;
    connectionStateForUser(userID: number): PeerConnectionState | null;
    attachMediaStream(elementId: string, stream: MediaStream, opt?: Media.ElementOptions): void;
    detachMediaStream(elementId: string, opt?: Media.ElementOptions): void;
    switchMediaTracks(options?: Media.TrackConstraintsOrDeviceIds): Promise<MediaStream>;
    call(extension?: Calls.UserInfo): void;
    private callInternal;
    accept(extension?: Calls.UserInfo): void;
    private acceptInternal;
    reject(extension?: Calls.UserInfo): void;
    stop(extension?: Calls.UserInfo): void;
    canInitiateIceRestart(userID: number): boolean;
    iceRestart(userID: number): Promise<void>;
    processOnCall(callerID: number, extension: Calls.ExtensionParams): void;
    processOnAccept(userID: number, extension: Calls.ExtensionParams): Promise<void>;
    processOnReject(userID: number): void;
    processOnStop(userID: number): void;
    processOnIceCandidates(userID: number, extension: Calls.ExtensionParams): Promise<void>;
    processOnIceRestart(userID: number, extension: Calls.ExtensionParams): Promise<void>;
    processOnIceRestartAccept(userID: number, extension: Calls.ExtensionParams): Promise<void>;
    processCall(peerConnection: WebRTCPeerConnection, extension?: Calls.ExtensionParams): void;
    processIceCandidates(userID: number, iceCandidates: RTCIceCandidateInit[]): void;
    processOnNotAnswer(peerConnection: WebRTCPeerConnection): void;
    onRemoteStream(userID: number, stream: MediaStream): void;
    onCallStatsReport(userID: number, stats: any, error?: Error): void;
    onSessionConnectionStateChanged(userID: number, connectionState: SessionConnectionState): void;
    private close;
    closeSessionIfAllConnectionsClosed(): void;
    private closeLocalMediaStream;
    mute(type: 'audio' | 'video'): void;
    unmute(type: 'audio' | 'video'): void;
    private muteStream;
    private clearAnswerTimer;
    private startAnswerTimer;
    private clearWaitingOfferOrAnswerTimer;
    private startWaitingOfferOrAnswerTimer;
    toString(): string;
    set startCallTime(date: Date);
    get startCallTime(): number;
    set acceptCallTime(date: Date);
    get acceptCallTime(): number;
}
//# sourceMappingURL=WebRTCSession.d.ts.map